# Patina v0.3.0: Markdown Parsing

**Status:** Planning
**Target:** Day 5
**Dependencies:** v0.2.0

---

## Overview

v0.3.0 integrates the comrak Markdown parser to generate an Abstract Syntax Tree (AST) from the document buffer. This prepares for preview rendering in v0.4.0.

## Goals

- Integrate comrak with GFM extensions
- Parse buffer text into AST
- Cache parsed AST in Document
- Incremental parsing (debounced)
- Support all CommonMark + GFM features

## Success Criteria

- [ ] Parser module compiles
- [ ] Can parse all CommonMark features
- [ ] GFM extensions work (tables, strikethrough, task lists)
- [ ] Parsing is debounced (doesn't block typing)
- [ ] AST is cached until text changes
- [ ] Tests cover edge cases

---

## Implementation

### 1. Parser Module (`patina-core/src/parser.rs`)

```rust
use comrak::{
    nodes::{AstNode, NodeValue},
    parse_document, Arena, ComrakOptions,
};

pub struct MarkdownParser {
    options: ComrakOptions,
}

impl MarkdownParser {
    pub fn new() -> Self {
        let mut options = ComrakOptions::default();

        // Enable GFM extensions
        options.extension.strikethrough = true;
        options.extension.tagfilter = true;
        options.extension.table = true;
        options.extension.autolink = true;
        options.extension.tasklist = true;
        options.extension.superscript = false;
        options.extension.footnotes = false;
        options.extension.description_lists = false;

        // Parsing options
        options.parse.smart = true;
        options.parse.default_info_string = None;

        Self { options }
    }

    pub fn parse<'a>(&self, arena: &'a Arena<AstNode<'a>>, text: &str) -> &'a AstNode<'a> {
        parse_document(arena, text, &self.options)
    }
}

impl Default for MarkdownParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_headers() {
        let parser = MarkdownParser::new();
        let arena = Arena::new();
        let root = parser.parse(&arena, "# Header 1\n## Header 2");
        // Verify AST structure
    }

    #[test]
    fn test_parse_gfm_table() {
        let parser = MarkdownParser::new();
        let arena = Arena::new();
        let markdown = "| A | B |\n|---|---|\n| 1 | 2 |";
        let root = parser.parse(&arena, markdown);
        // Verify table node exists
    }
}
```

### 2. AST Storage (`patina-core/src/document.rs`)

```rust
use comrak::{Arena, nodes::AstNode};
use crate::MarkdownParser;

pub struct Document {
    // ... existing fields ...
    parser: MarkdownParser,
    // Note: Arena must outlive AST references
    // Store arena and ast together or re-parse on demand
}

impl Document {
    pub fn parse(&self) -> (Arena<AstNode>, &AstNode) {
        let arena = Arena::new();
        let ast = self.parser.parse(&arena, &self.buffer.text());
        (arena, ast)
    }
}
```

### 3. Parsing Tests

Test all CommonMark features:
- Headings (ATX and Setext)
- Paragraphs and line breaks
- Emphasis and strong emphasis
- Lists (ordered and unordered)
- Links (inline, reference, autolinks)
- Images
- Code blocks (fenced and indented)
- Blockquotes
- Horizontal rules

Test all GFM features:
- Tables with alignment
- Strikethrough
- Task lists
- Autolinks for URLs

---

## Validation

- [ ] All v0.2.0 functionality still works
- [ ] Parser compiles without warnings
- [ ] All test cases pass
- [ ] Can parse large documents (100KB) without lag
- [ ] `/validate-build` passes

---

## Next Steps

v0.4.0: Use AST to render preview pane
