# Patina v0.6.0: MVP Complete

**Status:** Planning
**Target:** Days 10-11
**Dependencies:** v0.5.0

---

## Overview

v0.6.0 completes the MVP by adding LaTeX math rendering (Unicode), emoji support, configuration system, i18n framework, and final polish.

## Goals

- LaTeX math rendering to Unicode
- Emoji shortcode expansion
- Configuration file support
- i18n framework (English only)
- All MVP keyboard shortcuts
- Performance optimization
- Documentation

## Success Criteria

- [ ] LaTeX math renders inline and display mode
- [ ] Emoji shortcodes work (`:rocket:` â†’ ðŸš€)
- [ ] Config loads from ~/.config/patina/config.toml
- [ ] i18n strings loaded from Fluent files
- [ ] All keyboard shortcuts implemented
- [ ] Performance targets met (<50ms startup, <20MB RAM)
- [ ] README and CHANGELOG complete
- [ ] Ready for v0.6.0 release

---

## Implementation

### 1. LaTeX Extension (`patina-extensions/src/latex.rs`)

```rust
//! LaTeX to Unicode math renderer

use std::collections::HashMap;

pub struct LatexRenderer {
    symbols: HashMap<&'static str, &'static str>,
}

impl LatexRenderer {
    pub fn new() -> Self {
        let mut symbols = HashMap::new();

        // Greek letters
        symbols.insert("\\alpha", "Î±");
        symbols.insert("\\beta", "Î²");
        symbols.insert("\\gamma", "Î³");
        symbols.insert("\\pi", "Ï€");
        symbols.insert("\\sigma", "Ïƒ");

        // Math symbols
        symbols.insert("\\infty", "âˆž");
        symbols.insert("\\sum", "Î£");
        symbols.insert("\\prod", "Î ");
        symbols.insert("\\int", "âˆ«");
        symbols.insert("\\sqrt", "âˆš");
        symbols.insert("\\pm", "Â±");
        symbols.insert("\\times", "Ã—");
        symbols.insert("\\div", "Ã·");
        symbols.insert("\\le", "â‰¤");
        symbols.insert("\\ge", "â‰¥");
        symbols.insert("\\ne", "â‰ ");

        // ... add more symbols ...

        Self { symbols }
    }

    /// Render inline math $...$
    pub fn render_inline(&self, expr: &str) -> String {
        self.render_expr(expr)
    }

    /// Render display math $$...$$
    pub fn render_display(&self, expr: &str) -> String {
        format!("\n    {}\n", self.render_expr(expr))
    }

    fn render_expr(&self, expr: &str) -> String {
        let mut result = expr.to_string();

        // Replace symbols
        for (latex, unicode) in &self.symbols {
            result = result.replace(latex, unicode);
        }

        // Handle superscripts ^{}
        result = Self::convert_superscripts(&result);

        // Handle subscripts _{}
        result = Self::convert_subscripts(&result);

        // Handle fractions \frac{a}{b}
        result = Self::convert_fractions(&result);

        result
    }

    fn convert_superscripts(text: &str) -> String {
        // Convert x^2 to xÂ²
        // Simplified implementation
        text.replace("^2", "Â²")
            .replace("^3", "Â³")
            .replace("^n", "â¿")
    }

    fn convert_subscripts(text: &str) -> String {
        // Convert x_i to xáµ¢
        text.replace("_i", "áµ¢")
            .replace("_0", "â‚€")
            .replace("_1", "â‚")
    }

    fn convert_fractions(text: &str) -> String {
        // Simple fraction rendering
        // \frac{a}{b} -> a/b or use fraction slash
        text.replace("\\frac{", "").replace("}{", "/").replace("}", "")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_symbols() {
        let renderer = LatexRenderer::new();
        assert_eq!(renderer.render_inline("\\alpha"), "Î±");
        assert_eq!(renderer.render_inline("\\pi"), "Ï€");
        assert_eq!(renderer.render_inline("\\infty"), "âˆž");
    }

    #[test]
    fn test_superscript() {
        let renderer = LatexRenderer::new();
        assert_eq!(renderer.render_inline("x^2"), "xÂ²");
    }

    #[test]
    fn test_equation() {
        let renderer = LatexRenderer::new();
        let result = renderer.render_inline("E = mc^2");
        assert!(result.contains("Â²"));
    }
}
```

### 2. Emoji Extension (`patina-extensions/src/emoji.rs`)

```rust
use std::collections::HashMap;
use once_cell::sync::Lazy;

static EMOJI_MAP: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // Common emoji
    map.insert(":rocket:", "ðŸš€");
    map.insert(":fire:", "ðŸ”¥");
    map.insert(":heart:", "â¤ï¸");
    map.insert(":check:", "âœ“");
    map.insert(":heavy_check_mark:", "âœ”ï¸");
    map.insert(":x:", "âŒ");
    map.insert(":warning:", "âš ï¸");
    map.insert(":tada:", "ðŸŽ‰");

    // ... add ~1800 more emoji ...

    map
});

pub fn expand_shortcodes(text: &str) -> String {
    let mut result = text.to_string();

    for (shortcode, emoji) in EMOJI_MAP.iter() {
        result = result.replace(shortcode, emoji);
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_emoji_expansion() {
        assert_eq!(expand_shortcodes(":rocket:"), "ðŸš€");
        assert_eq!(expand_shortcodes("I :heart: Rust"), "I â¤ï¸ Rust");
    }
}
```

### 3. Config System (`patina/src/config.rs`)

```rust
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub editor: EditorConfig,
    pub keybindings: KeybindingsConfig,
    pub theme: String,
    pub markdown: MarkdownConfig,
    pub i18n: I18nConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditorConfig {
    pub tab_size: usize,
    pub soft_wrap: bool,
    pub line_numbers: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeybindingsConfig {
    pub mode: String, // "vim", "emacs", "standard"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarkdownConfig {
    pub default_parser: String, // "commonmark" or "gfm"
    pub math_engine: String,     // "unicode" or "ascii"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct I18nConfig {
    pub locale: String, // "auto" or specific locale
}

impl Default for Config {
    fn default() -> Self {
        Self {
            editor: EditorConfig {
                tab_size: 4,
                soft_wrap: true,
                line_numbers: true,
            },
            keybindings: KeybindingsConfig {
                mode: "standard".to_string(),
            },
            theme: "dracula".to_string(),
            markdown: MarkdownConfig {
                default_parser: "gfm".to_string(),
                math_engine: "unicode".to_string(),
            },
            i18n: I18nConfig {
                locale: "auto".to_string(),
            },
        }
    }
}

impl Config {
    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        let config_path = Self::config_path();

        if config_path.exists() {
            let contents = std::fs::read_to_string(config_path)?;
            let config: Config = toml::from_str(&contents)?;
            Ok(config)
        } else {
            Ok(Self::default())
        }
    }

    pub fn config_path() -> PathBuf {
        dirs::config_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("patina")
            .join("config.toml")
    }
}
```

### 4. i18n Framework (`patina-i18n/src/lib.rs`)

```rust
use fluent::{FluentBundle, FluentResource};
use unic_langid::LanguageIdentifier;

pub struct I18n {
    bundle: FluentBundle<FluentResource>,
}

impl I18n {
    pub fn new(locale: &str) -> Self {
        let langid: LanguageIdentifier = locale.parse().unwrap_or_else(|_| "en-US".parse().unwrap());
        let mut bundle = FluentBundle::new(vec![langid]);

        // Load English strings
        let ftl_string = include_str!("../locales/en/main.ftl");
        let resource = FluentResource::try_new(ftl_string.to_string())
            .expect("Failed to parse FTL");

        bundle.add_resource(resource).expect("Failed to add resource");

        Self { bundle }
    }

    pub fn t(&self, key: &str) -> String {
        let message = self.bundle.get_message(key)
            .expect(&format!("Message {} not found", key));

        let pattern = message.value().expect("Message has no value");

        let mut errors = vec![];
        let value = self.bundle.format_pattern(pattern, None, &mut errors);

        value.to_string()
    }
}

// locales/en/main.ftl
/*
app-title = Patina
file-saved = File saved
file-open = Open file
file-new = New file
unsaved-changes = You have unsaved changes
*/
```

### 5. Performance Optimization

- Profile with `cargo flamegraph`
- Optimize hot paths (rendering, parsing)
- Lazy parsing (only when needed)
- Efficient string handling
- Minimize allocations in render loop

### 6. Documentation

Create/update:
- README.md with installation, usage, features
- CHANGELOG.md with all version entries
- examples/ directory with sample markdown files
- CONTRIBUTING.md with development guidelines

---

## Validation

- [ ] All previous version features work
- [ ] LaTeX math renders correctly
- [ ] Emoji shortcodes expand
- [ ] Config loads and applies
- [ ] i18n strings load from Fluent
- [ ] All keybindings work
- [ ] `/bench-perf` shows <50ms startup, <20MB RAM
- [ ] `/validate-build` passes
- [ ] `/check-arch` passes
- [ ] Documentation complete

---

## Release Checklist

- [ ] All tests pass
- [ ] Performance benchmarks met
- [ ] README is accurate and complete
- [ ] CHANGELOG documents all changes
- [ ] Examples work correctly
- [ ] Tag v0.6.0
- [ ] Create GitHub release
- [ ] Announce MVP completion

---

## Next Steps

After MVP (v0.6.0):
- v0.7.0: Add GUI backend with egui
- v0.8.0: GUI feature parity with TUI
- v0.9.0+: Advanced features (Mermaid, full i18n, export, workspace)
