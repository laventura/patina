# Patina v0.2.0: Core Editing

**Status:** Planning
**Target:** Days 3-4
**Dependencies:** v0.1.0

---

## Overview

v0.2.0 transforms Patina from a read-only viewer into a functional text editor with cursor movement, text insertion/deletion, undo/redo, and file saving.

## Goals

### Primary
- Full cursor movement (arrows, Home/End, PgUp/PgDn)
- Text insertion and deletion
- Undo/redo with unlimited history
- Save files (Ctrl+S)
- Unsaved changes indicator

### Non-Goals (Deferred)
- Multiple cursors (v1.0+)
- Find/replace (v0.9+)
- Smart indentation (v0.9+)

## Success Criteria

- [ ] Can move cursor anywhere in document
- [ ] Can insert and delete text
- [ ] Undo/redo works for all operations
- [ ] Can save files with Ctrl+S
- [ ] Modified indicator appears when document changes
- [ ] All tests pass
- [ ] Performance: < 16ms keystroke response

---

## Technical Specification

### 1. Buffer Editing Operations (`patina-core/src/buffer.rs`)

Add these methods to `Buffer`:

```rust
/// Insert text at character position
pub fn insert(&mut self, char_idx: usize, text: &str) -> Result<()> {
    if char_idx > self.rope.len_chars() {
        return Err(Error::Buffer("Position out of bounds".into()));
    }
    self.rope.insert(char_idx, text);
    self.modified = true;
    Ok(())
}

/// Insert a single character
pub fn insert_char(&mut self, char_idx: usize, ch: char) -> Result<()> {
    self.insert(char_idx, &ch.to_string())
}

/// Delete range of characters
pub fn delete_range(&mut self, start: usize, end: usize) -> Result<()> {
    if start > self.rope.len_chars() || end > self.rope.len_chars() {
        return Err(Error::Buffer("Range out of bounds".into()));
    }
    self.rope.remove(start..end);
    self.modified = true;
    Ok(())
}

/// Delete single character
pub fn delete_char(&mut self, char_idx: usize) -> Result<()> {
    if char_idx >= self.rope.len_chars() {
        return Err(Error::Buffer("Position out of bounds".into()));
    }
    self.rope.remove(char_idx..char_idx + 1);
    self.modified = true;
    Ok(())
}

/// Insert newline at position
pub fn insert_newline(&mut self, char_idx: usize) -> Result<()> {
    self.insert(char_idx, "\n")
}

/// Get character at position
pub fn char_at(&self, char_idx: usize) -> Option<char> {
    self.rope.get_char(char_idx)
}
```

### 2. History System (`patina-core/src/history.rs`)

```rust
//! Undo/redo history using command pattern.

use std::collections::VecDeque;

/// Maximum history size (unlimited in practice, but cap at reasonable value)
const MAX_HISTORY: usize = 10_000;

/// A reversible command
pub trait Command: std::fmt::Debug {
    /// Execute the command
    fn execute(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()>;

    /// Undo the command
    fn undo(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()>;
}

/// Insert text command
#[derive(Debug, Clone)]
pub struct InsertCommand {
    pub position: usize,
    pub text: String,
}

impl Command for InsertCommand {
    fn execute(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()> {
        buffer.insert(self.position, &self.text)
    }

    fn undo(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()> {
        let end = self.position + self.text.len();
        buffer.delete_range(self.position, end)
    }
}

/// Delete text command
#[derive(Debug, Clone)]
pub struct DeleteCommand {
    pub position: usize,
    pub text: String, // Store deleted text for undo
}

impl Command for DeleteCommand {
    fn execute(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()> {
        let end = self.position + self.text.len();
        buffer.delete_range(self.position, end)
    }

    fn undo(&mut self, buffer: &mut crate::Buffer) -> crate::Result<()> {
        buffer.insert(self.position, &self.text)
    }
}

/// History manager for undo/redo
#[derive(Debug)]
pub struct History {
    undo_stack: VecDeque<Box<dyn Command>>,
    redo_stack: VecDeque<Box<dyn Command>>,
}

impl History {
    pub fn new() -> Self {
        Self {
            undo_stack: VecDeque::new(),
            redo_stack: VecDeque::new(),
        }
    }

    /// Execute and record a command
    pub fn execute(&mut self, mut cmd: Box<dyn Command>, buffer: &mut crate::Buffer) -> crate::Result<()> {
        cmd.execute(buffer)?;

        // Clear redo stack on new action
        self.redo_stack.clear();

        // Add to undo stack
        self.undo_stack.push_back(cmd);

        // Limit history size
        if self.undo_stack.len() > MAX_HISTORY {
            self.undo_stack.pop_front();
        }

        Ok(())
    }

    /// Undo last command
    pub fn undo(&mut self, buffer: &mut crate::Buffer) -> crate::Result<bool> {
        if let Some(mut cmd) = self.undo_stack.pop_back() {
            cmd.undo(buffer)?;
            self.redo_stack.push_back(cmd);
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Redo last undone command
    pub fn redo(&mut self, buffer: &mut crate::Buffer) -> crate::Result<bool> {
        if let Some(mut cmd) = self.redo_stack.pop_back() {
            cmd.execute(buffer)?;
            self.undo_stack.push_back(cmd);
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Check if undo is available
    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    /// Check if redo is available
    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }
}

impl Default for History {
    fn default() -> Self {
        Self::new()
    }
}
```

### 3. Document Cursor Operations (`patina-core/src/document.rs`)

Add to `Document`:

```rust
use crate::History;

pub struct Document {
    // ... existing fields ...
    pub history: History,
}

impl Document {
    /// Move cursor to position (with bounds checking)
    pub fn move_cursor(&mut self, line: usize, col: usize) {
        let max_line = self.buffer.len_lines().saturating_sub(1);
        let line = line.min(max_line);

        if let Some(line_text) = self.buffer.line(line) {
            let max_col = line_text.chars().count();
            let col = col.min(max_col);
            self.cursor = (line, col);
        }
    }

    /// Move cursor by delta
    pub fn move_cursor_by(&mut self, delta_line: isize, delta_col: isize) {
        let new_line = (self.cursor.0 as isize + delta_line).max(0) as usize;
        let new_col = (self.cursor.1 as isize + delta_col).max(0) as usize;
        self.move_cursor(new_line, new_col);
    }

    /// Get character index from line/column
    pub fn cursor_to_char_idx(&self) -> usize {
        self.buffer.rope.line_to_char(self.cursor.0) + self.cursor.1
    }

    /// Insert character at cursor
    pub fn insert_char(&mut self, ch: char) -> crate::Result<()> {
        let char_idx = self.cursor_to_char_idx();
        let cmd = Box::new(InsertCommand {
            position: char_idx,
            text: ch.to_string(),
        });
        self.history.execute(cmd, &mut self.buffer)?;

        // Move cursor forward
        if ch == '\n' {
            self.move_cursor(self.cursor.0 + 1, 0);
        } else {
            self.move_cursor(self.cursor.0, self.cursor.1 + 1);
        }

        Ok(())
    }

    /// Delete character before cursor (backspace)
    pub fn delete_char_before(&mut self) -> crate::Result<()> {
        if self.cursor == (0, 0) {
            return Ok(()); // Nothing to delete
        }

        let char_idx = self.cursor_to_char_idx();
        if char_idx == 0 {
            return Ok(());
        }

        let deleted_char = self.buffer.char_at(char_idx - 1).unwrap();
        let cmd = Box::new(DeleteCommand {
            position: char_idx - 1,
            text: deleted_char.to_string(),
        });
        self.history.execute(cmd, &mut self.buffer)?;

        // Move cursor back
        if deleted_char == '\n' {
            let prev_line = self.cursor.0.saturating_sub(1);
            let prev_line_len = self.buffer.line(prev_line)
                .map(|l| l.chars().count())
                .unwrap_or(0);
            self.move_cursor(prev_line, prev_line_len);
        } else {
            self.move_cursor(self.cursor.0, self.cursor.1.saturating_sub(1));
        }

        Ok(())
    }

    /// Undo last change
    pub fn undo(&mut self) -> crate::Result<bool> {
        self.history.undo(&mut self.buffer)
    }

    /// Redo last undone change
    pub fn redo(&mut self) -> crate::Result<bool> {
        self.history.redo(&mut self.buffer)
    }
}
```

### 4. Input Handling (`patina/src/app.rs`)

Update `handle_key` to support editing:

```rust
fn handle_key(&mut self, key: event::KeyEvent) -> Result<()> {
    use crossterm::event::{KeyCode, KeyModifiers};

    let ctrl = key.modifiers.contains(KeyModifiers::CONTROL);
    let shift = key.modifiers.contains(KeyModifiers::SHIFT);

    match (key.code, ctrl, shift) {
        // Quit
        (KeyCode::Char('q'), true, _) => {
            if self.document.buffer.is_modified() {
                // TODO: Show unsaved changes warning
            }
            self.should_quit = true;
        }

        // Save
        (KeyCode::Char('s'), true, _) => {
            if let Err(e) = self.document.save() {
                log::error!("Failed to save: {}", e);
            }
        }

        // Undo/Redo
        (KeyCode::Char('z'), true, false) => {
            let _ = self.document.undo();
        }
        (KeyCode::Char('y'), true, _) | (KeyCode::Char('z'), true, true) => {
            let _ = self.document.redo();
        }

        // Character input
        (KeyCode::Char(c), false, _) => {
            let _ = self.document.insert_char(c);
        }

        // Enter/newline
        (KeyCode::Enter, _, _) => {
            let _ = self.document.insert_char('\n');
        }

        // Backspace
        (KeyCode::Backspace, _, _) => {
            let _ = self.document.delete_char_before();
        }

        // Cursor movement
        (KeyCode::Left, _, _) => {
            self.document.move_cursor_by(0, -1);
        }
        (KeyCode::Right, _, _) => {
            self.document.move_cursor_by(0, 1);
        }
        (KeyCode::Up, _, _) => {
            self.document.move_cursor_by(-1, 0);
        }
        (KeyCode::Down, _, _) => {
            self.document.move_cursor_by(1, 0);
        }

        // Home/End
        (KeyCode::Home, _, _) => {
            self.document.move_cursor(self.document.cursor.0, 0);
        }
        (KeyCode::End, _, _) => {
            let line = self.document.cursor.0;
            if let Some(line_text) = self.document.buffer.line(line) {
                let len = line_text.chars().count();
                self.document.move_cursor(line, len);
            }
        }

        // Page Up/Down
        (KeyCode::PageUp, _, _) => {
            self.document.move_cursor_by(-20, 0);
        }
        (KeyCode::PageDown, _, _) => {
            self.document.move_cursor_by(20, 0);
        }

        _ => {}
    }

    Ok(())
}
```

### 5. UI Updates (`patina/src/ui.rs`)

Update status bar to show modified indicator:

```rust
let modified_indicator = if document.buffer.is_modified() {
    "[+] "
} else {
    ""
};

let status = format!(
    " {}{} | Ln {}, Col {} | {} ",
    modified_indicator,
    document.path.as_ref()
        .and_then(|p| p.file_name())
        .and_then(|n| n.to_str())
        .unwrap_or("[No Name]"),
    document.cursor.0 + 1,
    document.cursor.1 + 1,
    if document.history.can_undo() { "U" } else { "" },
);
```

---

## Testing Strategy

### Unit Tests
- Buffer insert/delete operations
- History undo/redo
- Cursor position calculations
- Edge cases: beginning/end of file, empty lines

### Integration Tests
- Type text, undo, redo
- Save file after editing
- Move cursor to various positions

### Manual Tests
- Type a paragraph
- Delete with backspace
- Undo several times, redo
- Move cursor with all methods (arrows, Home/End, PgUp/PgDn)
- Edit multi-line document
- Save and reload

---

## Performance Targets

| Metric | Target |
|--------|--------|
| Keystroke latency | < 16ms (60 FPS) |
| Undo/redo speed | < 5ms |
| Save operation | < 100ms for 1MB file |

---

## Validation Checklist

- [ ] All v0.1.0 tests still pass
- [ ] New tests for editing operations pass
- [ ] `/validate-build` passes
- [ ] `/check-arch` passes
- [ ] Can type and edit text smoothly
- [ ] Undo/redo works correctly
- [ ] Cursor moves accurately
- [ ] Modified indicator appears
- [ ] Can save files
- [ ] Performance targets met

---

## Known Issues / Limitations

- No selection/copy/paste (v0.3+)
- No find/replace (v0.9+)
- No multi-line undo grouping (types one char at a time)
- No smart indentation

---

## Next Steps

After v0.2.0:
- Proceed to v0.3.0 (Markdown Parsing)
- Integrate comrak for CommonMark parsing
- Generate AST for preview rendering
