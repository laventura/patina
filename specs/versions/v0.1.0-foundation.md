# Patina v0.1.0: Foundation

**Status:** Planning
**Target:** Days 1-2
**Dependencies:** None

---

## Overview

v0.1.0 establishes the workspace architecture and creates a minimal working TUI application that can open and display text files using a rope-based buffer.

## Goals

### Primary
- Establish Cargo workspace with all 6 crates
- Implement rope-based text buffer in `patina-core`
- Create basic TUI shell with ratatui
- Open and display files

### Non-Goals (Deferred)
- Text editing (v0.2.0)
- Markdown parsing (v0.3.0)
- Preview pane (v0.4.0)

## Success Criteria

- [ ] `cargo build --workspace` succeeds with zero warnings
- [ ] `cargo test --workspace` passes all tests
- [ ] `patina examples/test.md` opens file and displays content
- [ ] Can quit with Ctrl+Q
- [ ] `/validate-build` skill passes
- [ ] Binary size < 5MB (no bloat)
- [ ] Startup time < 20ms (measured with `time`)

---

## Technical Specification

### Architecture

```
patina/
├── crates/
│   ├── patina/              # TUI binary
│   │   ├── src/
│   │   │   ├── main.rs      # CLI entry point, arg parsing
│   │   │   ├── app.rs       # Application state
│   │   │   └── ui.rs        # Rendering logic
│   │   └── Cargo.toml
│   │
│   ├── patina-core/         # Core library
│   │   ├── src/
│   │   │   ├── lib.rs       # Public API, re-exports
│   │   │   ├── buffer.rs    # Text buffer (Rope)
│   │   │   └── document.rs  # Document model
│   │   └── Cargo.toml
│   │
│   ├── patina-render/       # Rendering backends
│   │   ├── src/
│   │   │   ├── lib.rs       # Feature-gated modules
│   │   │   └── tui/
│   │   │       └── mod.rs   # TUI init/restore
│   │   └── Cargo.toml
│   │
│   ├── patina-extensions/   # Extensions (stub)
│   │   ├── src/
│   │   │   └── lib.rs
│   │   └── Cargo.toml
│   │
│   ├── patina-i18n/         # i18n (stub)
│   │   ├── src/
│   │   │   └── lib.rs
│   │   └── Cargo.toml
│   │
│   └── patina-gui/          # GUI binary (stub)
│       ├── src/
│       │   └── main.rs
│       └── Cargo.toml
│
├── Cargo.toml               # Workspace manifest
└── .claude/skills/          # Skills we created
```

### Data Flow

```
User runs: patina test.md
    ↓
main.rs: Parse CLI args (clap)
    ↓
app.rs: Initialize App state
    ↓
Document::from_file("test.md")
    ↓
Buffer::from_str(file_contents)
    ↓
Rope::from_str(text)  # ropey
    ↓
ui.rs: Render buffer to terminal
    ↓
Event loop: Wait for Ctrl+Q
```

---

## Implementation Details

### 1. Workspace Setup (Cargo.toml)

```toml
[workspace]
resolver = "2"
members = [
    "crates/patina",
    "crates/patina-gui",
    "crates/patina-core",
    "crates/patina-render",
    "crates/patina-extensions",
    "crates/patina-i18n",
]

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "MIT"
authors = ["Atul Acharya"]
repository = "https://github.com/laventura/patina"

[workspace.dependencies]
# Core
ropey = "1.6"

# TUI
ratatui = "0.28"
crossterm = "0.27"

# CLI
clap = { version = "4", features = ["derive"] }

# Utilities
anyhow = "1"
log = "0.4"
env_logger = "0.11"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
strip = true
```

### 2. Text Buffer (`patina-core/src/buffer.rs`)

```rust
//! Text buffer implementation using rope data structure.

use ropey::Rope;

/// A text buffer backed by a rope.
#[derive(Debug, Clone)]
pub struct Buffer {
    /// The underlying rope
    rope: Rope,
    /// Whether modified since last save
    modified: bool,
}

impl Buffer {
    /// Create empty buffer
    pub fn new() -> Self {
        Self {
            rope: Rope::new(),
            modified: false,
        }
    }

    /// Create buffer from string
    pub fn from_str(text: &str) -> Self {
        Self {
            rope: Rope::from_str(text),
            modified: false,
        }
    }

    /// Get entire text as String
    pub fn text(&self) -> String {
        self.rope.to_string()
    }

    /// Get number of lines
    pub fn len_lines(&self) -> usize {
        self.rope.len_lines()
    }

    /// Get line at index (0-based)
    pub fn line(&self, idx: usize) -> Option<String> {
        if idx < self.len_lines() {
            Some(self.rope.line(idx).to_string())
        } else {
            None
        }
    }

    /// Get total character count
    pub fn len_chars(&self) -> usize {
        self.rope.len_chars()
    }

    /// Check if buffer is empty
    pub fn is_empty(&self) -> bool {
        self.rope.len_chars() == 0
    }

    /// Check if buffer has been modified
    pub fn is_modified(&self) -> bool {
        self.modified
    }

    /// Mark buffer as saved
    pub fn mark_saved(&mut self) {
        self.modified = false;
    }
}

impl Default for Buffer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_buffer() {
        let buf = Buffer::new();
        assert_eq!(buf.len_lines(), 1); // Empty rope has 1 line
        assert_eq!(buf.len_chars(), 0);
        assert!(buf.is_empty());
        assert!(!buf.is_modified());
    }

    #[test]
    fn test_from_str() {
        let buf = Buffer::from_str("Hello\nWorld");
        assert_eq!(buf.len_lines(), 2);
        assert_eq!(buf.len_chars(), 11);
        assert!(!buf.is_empty());
        assert_eq!(buf.text(), "Hello\nWorld");
    }

    #[test]
    fn test_line_access() {
        let buf = Buffer::from_str("Line 1\nLine 2\nLine 3");
        assert_eq!(buf.line(0).unwrap(), "Line 1\n");
        assert_eq!(buf.line(1).unwrap(), "Line 2\n");
        assert_eq!(buf.line(2).unwrap(), "Line 3");
        assert!(buf.line(3).is_none());
    }
}
```

### 3. Document Model (`patina-core/src/document.rs`)

```rust
//! Document model combining buffer and file metadata.

use std::path::PathBuf;
use std::io;
use crate::Buffer;

/// A document with buffer and metadata.
#[derive(Debug)]
pub struct Document {
    /// Text buffer
    pub buffer: Buffer,
    /// File path (None if untitled)
    pub path: Option<PathBuf>,
    /// Cursor position (line, column)
    pub cursor: (usize, usize),
    /// Scroll offset for view
    pub scroll_offset: usize,
}

impl Document {
    /// Create new empty document
    pub fn new() -> Self {
        Self {
            buffer: Buffer::new(),
            path: None,
            cursor: (0, 0),
            scroll_offset: 0,
        }
    }

    /// Load document from file
    pub fn from_file(path: PathBuf) -> io::Result<Self> {
        let content = std::fs::read_to_string(&path)?;
        let mut doc = Self {
            buffer: Buffer::from_str(&content),
            path: Some(path),
            cursor: (0, 0),
            scroll_offset: 0,
        };
        doc.buffer.mark_saved();
        Ok(doc)
    }

    /// Save document to file
    pub fn save(&mut self) -> io::Result<()> {
        if let Some(path) = &self.path {
            std::fs::write(path, self.buffer.text())?;
            self.buffer.mark_saved();
            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::NotFound,
                "No file path set",
            ))
        }
    }
}

impl Default for Document {
    fn default() -> Self {
        Self::new()
    }
}
```

### 4. TUI Application (`patina/src/main.rs`)

```rust
//! Patina TUI entry point.

use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;

mod app;
mod ui;

#[derive(Parser)]
#[command(name = "patina")]
#[command(about = "A fast, lightweight Markdown editor", version)]
struct Args {
    /// File to open
    file: Option<PathBuf>,
}

fn main() -> Result<()> {
    env_logger::init();

    let args = Args::parse();

    let mut app = app::App::new(args.file)?;
    app.run()?;

    Ok(())
}
```

### 5. TUI Application State (`patina/src/app.rs`)

```rust
//! Main application logic.

use anyhow::Result;
use crossterm::event::{self, Event, KeyCode};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::io;
use std::path::PathBuf;
use std::time::Duration;

use patina_core::Document;
use crate::ui;

pub struct App {
    document: Document,
    should_quit: bool,
}

impl App {
    pub fn new(path: Option<PathBuf>) -> Result<Self> {
        let document = if let Some(p) = path {
            Document::from_file(p)?
        } else {
            Document::new()
        };

        Ok(Self {
            document,
            should_quit: false,
        })
    }

    pub fn run(&mut self) -> Result<()> {
        // Setup terminal
        crossterm::terminal::enable_raw_mode()?;
        let mut stdout = io::stdout();
        crossterm::execute!(
            stdout,
            crossterm::terminal::EnterAlternateScreen,
            crossterm::event::EnableMouseCapture
        )?;

        let backend = CrosstermBackend::new(stdout);
        let mut terminal = Terminal::new(backend)?;

        // Main loop
        while !self.should_quit {
            terminal.draw(|f| ui::draw(f, &self.document))?;

            if event::poll(Duration::from_millis(100))? {
                if let Event::Key(key) = event::read()? {
                    self.handle_key(key)?;
                }
            }
        }

        // Restore terminal
        crossterm::terminal::disable_raw_mode()?;
        crossterm::execute!(
            terminal.backend_mut(),
            crossterm::terminal::LeaveAlternateScreen,
            crossterm::event::DisableMouseCapture
        )?;
        terminal.show_cursor()?;

        Ok(())
    }

    fn handle_key(&mut self, key: event::KeyEvent) -> Result<()> {
        use crossterm::event::KeyModifiers;

        match (key.code, key.modifiers) {
            (KeyCode::Char('q'), KeyModifiers::CONTROL) => {
                self.should_quit = true;
            }
            _ => {}
        }

        Ok(())
    }
}
```

### 6. TUI Rendering (`patina/src/ui.rs`)

```rust
//! UI rendering logic.

use ratatui::{
    layout::{Constraint, Direction, Layout},
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
    Frame,
};

use patina_core::Document;

pub fn draw(frame: &mut Frame, document: &Document) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Min(1),       // Main content
            Constraint::Length(1),    // Status bar
        ])
        .split(frame.area());

    // Main content area
    let text_lines: Vec<Line> = document
        .buffer
        .text()
        .lines()
        .map(|line| Line::from(line.to_string()))
        .collect();

    let content = Paragraph::new(text_lines)
        .block(Block::default().borders(Borders::ALL).title("Patina"));

    frame.render_widget(content, chunks[0]);

    // Status bar
    let status = format!(
        " {} | Ln {}, Col {} | Press Ctrl+Q to quit ",
        document.path.as_ref()
            .and_then(|p| p.file_name())
            .and_then(|n| n.to_str())
            .unwrap_or("[No Name]"),
        document.cursor.0 + 1,
        document.cursor.1 + 1,
    );

    let status_bar = Paragraph::new(status)
        .style(Style::default().bg(Color::DarkGray).fg(Color::White));

    frame.render_widget(status_bar, chunks[1]);
}
```

---

## Testing Strategy

### Unit Tests
- `patina-core::buffer` - All buffer operations
- `patina-core::document` - File I/O, initialization

### Integration Tests
- Open file and verify buffer contents
- Handle non-existent files gracefully
- Handle empty files

### Manual Tests
- Open various file sizes (1KB, 100KB, 1MB)
- Test with Unicode content (emoji, CJK characters)
- Test with different line endings (LF, CRLF)
- Test on macOS, Linux, Windows

---

## Performance Targets

| Metric | Target | How to Measure |
|--------|--------|----------------|
| Startup time | < 20ms | `time cargo run --release -- test.md` |
| Memory (idle) | < 10MB | `ps aux \| grep patina` |
| Binary size | < 5MB | `ls -lh target/release/patina` |

---

## Validation Checklist

Before tagging v0.1.0:

- [ ] `cargo build --workspace` succeeds
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace` reports zero warnings
- [ ] `cargo fmt --check` passes
- [ ] `/validate-build` skill passes
- [ ] `/check-arch` skill passes
- [ ] Can open and display text files
- [ ] Ctrl+Q quits the application
- [ ] Status bar shows filename and cursor position
- [ ] Performance targets met
- [ ] README updated with v0.1.0 status
- [ ] CHANGELOG.md created with v0.1.0 entry

---

## Dependencies

```toml
# patina-core/Cargo.toml
[dependencies]
ropey = "1.6"

# patina/Cargo.toml
[dependencies]
patina-core = { path = "../patina-core" }
ratatui = "0.28"
crossterm = "0.27"
clap = { version = "4", features = ["derive"] }
anyhow = "1"
log = "0.4"
env_logger = "0.11"
```

---

## Known Limitations

- No text editing (read-only)
- No markdown rendering (displays as plain text)
- No syntax highlighting
- No split view
- Single file only
- No configuration

These will be addressed in subsequent versions.

---

## Next Steps

After v0.1.0 is complete and validated:
- Proceed to v0.2.0 (Core Editing)
- Add cursor movement and text insertion/deletion
- Implement undo/redo with History system
